<!DOCTYPE html>
<html>
<head>
    <title>Test WAV Conversion</title>
</head>
<body>
    <h1>Test WAV Conversion</h1>
    <button id="test-button">Test audioBufferToWav function</button>
    <div id="result"></div>

    <script>
        // Copy the audioBufferToWav function from our component
        const audioBufferToWav = (audioBuffer) => {
            const numberOfChannels = audioBuffer.numberOfChannels
            const sampleRate = audioBuffer.sampleRate
            const length = audioBuffer.length * numberOfChannels * 2 + 44
            
            const buffer = new ArrayBuffer(length)
            const view = new DataView(buffer)
            
            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i))
                }
            }
            
            let pos = 0
            
            // RIFF identifier
            writeString(pos, 'RIFF'); pos += 4
            // File length minus RIFF identifier length and file description length
            view.setUint32(pos, length - 8, true); pos += 4
            // RIFF type
            writeString(pos, 'WAVE'); pos += 4
            // Format chunk identifier
            writeString(pos, 'fmt '); pos += 4
            // Format chunk length
            view.setUint32(pos, 16, true); pos += 4
            // Sample format (raw)
            view.setUint16(pos, 1, true); pos += 2
            // Channel count
            view.setUint16(pos, numberOfChannels, true); pos += 2
            // Sample rate
            view.setUint32(pos, sampleRate, true); pos += 4
            // Byte rate (sample rate * block align)
            view.setUint32(pos, sampleRate * numberOfChannels * 2, true); pos += 4
            // Block align (channel count * bytes per sample)
            view.setUint16(pos, numberOfChannels * 2, true); pos += 2
            // Bits per sample
            view.setUint16(pos, 16, true); pos += 4
            // Data chunk identifier
            writeString(pos, 'data'); pos += 4
            // Data chunk length
            view.setUint32(pos, audioBuffer.length * numberOfChannels * 2, true); pos += 4
            
            // Write the PCM samples
            const offset = pos
            for (let i = 0; i < audioBuffer.length; i++) {
                for (let channel = 0; channel < numberOfChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, audioBuffer.getChannelData(channel)[i]))
                    view.setInt16(offset + (i * numberOfChannels + channel) * 2, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true)
                }
            }
            
            return new Blob([buffer], { type: 'audio/wav' })
        }

        document.getElementById('test-button').addEventListener('click', async () => {
            try {
                // Create a test audio buffer
                const audioContext = new AudioContext()
                const sampleRate = audioContext.sampleRate
                const duration = 1 // 1 second
                const length = sampleRate * duration
                
                const audioBuffer = audioContext.createBuffer(2, length, sampleRate)
                
                // Generate a simple sine wave for testing
                for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                    const channelData = audioBuffer.getChannelData(channel)
                    for (let i = 0; i < length; i++) {
                        channelData[i] = Math.sin(2 * Math.PI * 440 * i / sampleRate) * 0.1 // 440Hz sine wave
                    }
                }
                
                // Test our WAV conversion
                const wavBlob = audioBufferToWav(audioBuffer)
                
                document.getElementById('result').innerHTML = `
                    <p>✅ WAV conversion successful!</p>
                    <p>Original buffer: ${audioBuffer.numberOfChannels} channels, ${audioBuffer.sampleRate}Hz, ${audioBuffer.length} samples</p>
                    <p>WAV blob size: ${wavBlob.size} bytes</p>
                    <p>WAV blob type: ${wavBlob.type}</p>
                    <a href="${URL.createObjectURL(wavBlob)}" download="test.wav">Download Test WAV</a>
                `
                
                audioContext.close()
            } catch (error) {
                document.getElementById('result').innerHTML = `
                    <p>❌ Error: ${error.message}</p>
                `
            }
        })
    </script>
</body>
</html>